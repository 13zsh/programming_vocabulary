
 (function () { var old = $.fn.contents; $.fn.contents = function () { try { return old.apply(this, arguments); } catch (e) { return $([]); } } })() 
 
 
 
 
 
 
 
 Stack Overflow 
 
 
 
 
 Questions 
 
 
 Developer Jobs 
 
 
 Documentation  beta 
 
 
 Tags 
 
 
 Users 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 current community 
 
 
 
 
 
 
 help 
 chat 
 
 
 
        Stack Overflow
     
 
 
 
 
 
 
 
        Meta Stack Overflow
     
 
 
 
 
 
your communities             
 
 
 
 Sign up  or  log in  to customize your list.
                 
 
 
 more stack exchange communities 
 
 company blog 
 
 
 
 
 
 
 
 
 
 
                            Tour
                             
                                Start here for a quick overview of the site
                             
 
 
 
 
                        Help Center
                         
                            Detailed answers to any questions you might have
                         
 
 
 
 
                                Meta
                                 
                                    Discuss the workings and policies of this site
                                 
 
 
 
 
                                About Us
                                 
                                    Learn more about Stack Overflow the company
                                 
 
 
 
 
                                Business
                                 
                                    Learn more about hiring developers or posting ads with us
                                 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 Log In 
 Sign Up 
 
 
 
 
 
        StackExchange.ready(function () { StackExchange.topbar.init(); });
            StackExchange.scrollPadding.setPaddingTop(60, 10);      
 
 
 
 
 algorithm 
 
 
 
 
   
 
 
 
 
 dashboard 
 all topics 
 
 
 
 
 
 
 
 
 
 Popular 
 
 
 
 
 
 
 
 
 
 
        StackExchange.ready(function () {
            StackExchange.docs.search.init({
                popularTopicsJson: [{"Id":1529,"DocTag":"algorithm","Title":"Algorithm Complexity","Url":"/documentation/algorithm/1529/algorithm-complexity"},{"Id":757,"DocTag":"algorithm","Title":"Getting started with algorithm","Url":"/documentation/algorithm/757/getting-started-with-algorithm"},{"Id":4770,"DocTag":"algorithm","Title":"Big-O Notation","Url":"/documentation/algorithm/4770/big-o-notation"},{"Id":5735,"DocTag":"algorithm","Title":"Binary Search Trees","Url":"/documentation/algorithm/5735/binary-search-trees"},{"Id":2299,"DocTag":"algorithm","Title":"Graph","Url":"/documentation/algorithm/2299/graph"}]
            });
        });
     
   
 
 
 
 Topic 
 
 
 
 
 
 
 You must  sign up  or  log in  to make a topic request. 
 
 
 
 
 
 
 
    StackExchange.ready(function () {
        StackExchange.docs.requestTopic.init('algorithm');
    });
   
 
 
 
 
 
 
 Breadth-First Search 
 
 
 
 topic 
 discuss 
 
 
 
 
 Title 
 
 
 
 Versions 
 
 
 Introduction 
 
 
 
 
 
 
 
 
 
 
   add introduction 
 edit 
 share 
 request improvement 
   edit 
 move 
 delete topic 
 share 
 
 
 
 
 
                var ados = ados || {}; ados.run = ados.run || [];
                ados.run.push(function () { ados_add_placement(22,499571,"adzerk1561002845",4).setZone(29); });
             
 
 
 
 
 This draft deletes the entire topic. 
 
 
 
 
 
 
 
 
                    Examples
                     
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 4 
 
 Finding the Shortest Path from Source to other Nodes 
 
 
 
 
 
 4 
 
 
 
 
 
   
 Breadth-first-search  (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors. BFS was invented in the late 1950s by  Edward Forrest Moore , who used it to find the shortest path out of a maze and discovered independently by C. Y. Lee as a wire routing algorithm in 1961. 
 The processes of BFS algorithm works under these assumptions: 
 
 We won't traverse any node more than once. 
 Source node or the node that we're starting from is situated in level 0. 
 The nodes we can directly reach from source node are level 1 nodes, the nodes we can directly reach from level 1 nodes are level 2 nodes and so on. 
 The level denotes the distance of the shortest path from the source. 
 
 Let's see an example:
 
 Let's assume this graph represents connection between multiple cities, where each node denotes a city and an edge between two nodes denote there is a road linking them. We want to go from  node 1  to  node 10 . So  node 1  is our  source , which is  level 0 . We mark  node 1  as visited. We can go to  node 2 ,  node 3  and  node 4  from here. So they'll be  level (0+1)  =  level 1  nodes. Now we'll mark them as visited and work with them. 
 
 The colored nodes are visited. The nodes that we're currently working with will be marked with pink. We won't visit the same node twice. From  node 2 ,  node 3  and  node 4 , we can go to  node 6,   node 7  and  node 8 . Let's mark them as visited. The level of these nodes will be  level (1+1)  =  level 2 .  
 If you haven't noticed, the level of nodes simply denote the shortest path distance from the  source . For example: we've found  node 8  on  level 2 . So the distance from  source  to  node 8  is  2 . 
 We didn't yet reach our target node, that is  node 10 . So let's visit the next nodes. we can directly go to from  node 6 ,  node 7  and  node 8 . 
 We can see that, we found  node 10  at  level 3 . So the shortest path from  source  to  node 10  is  3.  We searched the graph level by level and found the shortest path. Now let's erase the edges that we didn't use:  
 After removing the edges that we didn't use, we get a tree called BFS tree. This tree shows the shortest path from  source  to all other nodes. 
 So our task will be, to go from  source  to  level 1  nodes. Then from  level 1  to  level 2  nodes and so on until we reach our destination. We can use  queue  to store the nodes that we are going to process. That is, for each node we're going to work with, we'll push all other nodes that can be directly traversed and not yet traversed in the queue. 
 The simulation of our example: 
 First we push the source in the queue. Our queue will look like: 
  front
+-----+
|  1  |
+-----+
 
 The level of  node 1  will be 0.  level[1]  =  0 . Now we start our BFS. At first, we pop a node from our queue. We get  node 1 . We can go to  node 4 ,  node 3  and  node 2  from this one. We've reached these nodes from  node 1 . So  level[4]  =  level[3]  =  level[2]  =  level[1]  +  1  =  1 . Now we mark them as visited and push them in the queue. 
                    front
+-----+  +-----+  +-----+
|  2  |  |  3  |  |  4  |
+-----+  +-----+  +-----+
 
 Now we pop  node 4  and work with it. We can go to  node 7  from  node 4 .  level[7]  =  level[4]  +  1  =  2 . We mark  node 7  as visited and push it in the queue. 
                    front
+-----+  +-----+  +-----+
|  7  |  |  2  |  |  3  |
+-----+  +-----+  +-----+
 
 From  node 3 , we can go to  node 7  and  node 8 . Since we've already marked  node 7  as visited, we mark  node 8  as visited, we change  level[8]  =  level[3]  +  1  =  2 . We push  node 8  in the queue. 
                    front
+-----+  +-----+  +-----+
|  6  |  |  7  |  |  2  |
+-----+  +-----+  +-----+
 
 This process will continue till we reach our destination or the queue becomes empty. The  level  array will provide us with the distance of the shortest path from  source . We can initialize  level  array with  infinity  value, which will mark that the nodes are not yet visited. Our pseudo-code will be: 
 Procedure BFS(Graph, source):
Q = queue();
level[] = infinity
level[source] := 0
Q.push(source)
while Q is not empty
    u -> Q.pop()
    for all edges from u to v in Adjacency list
        if level[v] == infinity
            level[v] := level[u] + 1
            Q.push(v)
        end if
    end for
end while
Return level
 
 By iterating through the  level  array, we can find out the distance of each node from source. For example: the distance of  node 10  from  source  will be stored in  level[10] . 
 Sometimes we might need to print not only the shortest distance, but also the path via which we can go to our destined node from the  source . For this we need to keep a  parent  array.  parent[source]  will be NULL. For each update in  level  array, we'll simply add  parent[v] := u  in our pseudo code inside the for loop. After finishing BFS, to find the path, we'll traverse back the  parent  array until we reach  source  which will be denoted by NULL value. The pseudo-code will be: 
 Procedure PrintPath(u):  //recursive    |   Procedure PrintPath(u):   //iterative
if parent[u] is not equal to null       |   S =  Stack()
    PrintPath(parent[u])                |   while parent[u] is not equal to null    
end if                                  |       S.push(u)
print -> u                              |       u := parent[u]
                                        |   end while
                                        |   while S is not empty
                                        |       print -> S.pop
                                        |   end while
 
 Complexity: 
 We've visited every node once and every edges once. So the complexity will be  O(V + E)  where  V  is the number of nodes and  E  is the number of edges. 
 
 
 
 
 
 
 
 edited  Oct 26 '16 at 15:46 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
   edit 
 share 
 discuss 
 request improvement 
   edit 
 move example 
 delete example 
 
 
 
 
 
 
 
 
 
 
 
 
 1 
 
 Finding Shortest Path from Source in a  2D graph 
 
 
 
 
 
 1 
 
 
 Most of the time, we'll need to find out the shortest path from single source to all other nodes or a specific node in a 2D graph. Say for example: we want to find out how many moves are required for a knight to reach a certain square in a chessboard, or we have an array where some cells are blocked, we have to find out the shortest path from one cell to another. We can move only horizontally and vertically. Even diagonal moves can be possible too. For these cases, we can convert the squares or cells in nodes and solve these problems easily using BFS. Now our  visited ,  parent  and  level  will be 2D arrays. For each node, we'll consider all possible moves. To find the distance to a specific node, we'll also check whether we have reached our destination. 
 There will be one additional thing called direction array. This will simply store the all possible combinations of directions we can go to. Let's say, for horizontal and vertical moves, our direction arrays will be: 
 +----+-----+-----+-----+-----+
| dx |  1  |  -1 |  0  |  0  |
+----+-----+-----+-----+-----+
| dy |  0  |   0 |  1  |  -1 |
+----+-----+-----+-----+-----+
 
 Here  dx  represents move in x-axis and  dy  represents move in y-axis. Again this part is optional. You can also write all the possible combinations separately. But it's easier to handle it using direction array. There can be more and even different combinations for diagonal moves or knight moves. 
 The additional part we need to keep in mind is: 
 
 If any of the cell is blocked, for every possible moves, we'll check if the cell is blocked or not. 
 We'll also check if we have gone out of bounds, that is we've crossed the array boundaries. 
 The number of rows and columns will be given. 
 
 Our pseudo-code will be: 
 Procedure BFS2D(Graph, blocksign, row, column):
for i from 1 to row
    for j from 1 to column
        visited[i][j] := false
    end for
end for
visited[source.x][source.y] := true
level[source.x][source.y] := 0
Q = queue()
Q.push(source)
m := dx.size
while Q is not empty
    top := Q.pop
    for i from 1 to m
        temp.x := top.x + dx[i]
        temp.y := top.y + dy[i]
        if temp is inside the row and column and top doesn't equal to blocksign
            visited[temp.x][temp.y] := true
            level[temp.x][temp.y] := level[top.x][top.y] + 1
            Q.push(temp)
        end if
    end for
end while
Return level
 
 As we have discussed earlier, BFS only works for unweighted graphs. For weighted graphs, we'll need  Dijkstra 's algorithm. For negative edge cycles, we need  Bellman-Ford 's algorithm. Again this algorithm is single source shortest path algorithm. If we need to find out distance from each nodes to all other nodes, we'll need  Floyd-Warshall 's algorithm. 
 
 
 
 
 
 
 
 created  Oct 3 '16 at 22:01 
 
 
 
 
 
 
 
 
   
 
 
   edit 
 share 
 discuss 
 request improvement 
   edit 
 move example 
 delete example 
 
 
 
   
 
                var ados = ados || {}; ados.run = ados.run || [];
                ados.run.push(function () { ados_add_placement(22,499571,"adzerk960387629",4).setZone(30); });
             
 
 
   
 
 
 
 
 
 
 
 
 0 
 
 Connected Components Of Undirected Graph Using BFS. 
 
 
 
 
 
 0 
 
 
 BFS  can be used to find the connected components of an  undirected graph . We can also find if the given graph is connected or not. Our subsequent discussion assumes we are dealing with undirected graphs.The definition of a connected graph is: 
 
 A graph is connected if there is a path between every pair of
vertices. 
 
 Following is a  connected graph . 
 
 Following graph is  not connected  and has 2 connected components: 
 
 Connected Component 1: {a,b,c,d,e} 
 Connected Component 2: {f} 
 
 
 BFS is a graph traversal algorithm. So starting from a random source node, if on termination of algorithm, all nodes are visited, then the graph is connected,otherwise it is not connected. 
 PseudoCode for the algorithm. 
 boolean isConnected(Graph g)
{     
 BFS(v)//v is a random source node.
 if(allVisited(g))
 {
  return true;
 }
 else return false;
}
 
 C implementation for finding the whether an undirected graph is connected or not: 
 #include<stdio.h>
#include<stdlib.h>
#define MAXVERTICES 100    

void enqueue(int);
int deque();
int isConnected(char **graph,int noOfVertices);
void BFS(char **graph,int vertex,int noOfVertices);    
int count = 0;
//Queue node depicts a single Queue element
//It is NOT a graph node.
struct node
{
    int v;
    struct node *next;
};

typedef struct node Node;
typedef struct node *Nodeptr;

Nodeptr Qfront = NULL;
Nodeptr Qrear = NULL;
char *visited;//array that keeps track of visited vertices.

int main()
{
    int n,e;//n is number of vertices, e is number of edges.
    int i,j;
    char **graph;//adjacency matrix

    printf("Enter number of vertices:");
    scanf("%d",&n);

    if(n < 0 || n > MAXVERTICES)
    {
     fprintf(stderr, "Please enter a valid positive integer from 1 to %d",MAXVERTICES);
     return -1;
    }

    graph = malloc(n * sizeof(char *));
    visited = malloc(n*sizeof(char));

    for(i = 0;i < n;++i)
    {
        graph[i] = malloc(n*sizeof(int));
        visited[i] = 'N';//initially all vertices are not visited.
        for(j = 0;j < n;++j)
            graph[i][j] = 0;
    }

    printf("enter number of edges and then enter them in pairs:");
    scanf("%d",&e);

    for(i = 0;i < e;++i)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        graph[u-1][v-1] = 1;
        graph[v-1][u-1] = 1;
    }    
    
    if(isConnected(graph,n))
        printf("The graph is connected");
    else printf("The graph is NOT connected\n");       
}

void enqueue(int vertex)
{
    if(Qfront == NULL)
    {
        Qfront = malloc(sizeof(Node));
        Qfront->v = vertex;
        Qfront->next = NULL;
        Qrear = Qfront;
    }
    else
    {
        Nodeptr newNode = malloc(sizeof(Node));
        newNode->v = vertex;
        newNode->next = NULL;
        Qrear->next = newNode;
        Qrear = newNode;
    }
}

int deque()
{
    if(Qfront == NULL)
    {
        printf("Q is empty , returning -1\n");
        return -1;
    }
    else
    {
        int v = Qfront->v;
        Nodeptr temp= Qfront;
        if(Qfront == Qrear)
        {
            Qfront = Qfront->next;
            Qrear = NULL;
        }
        else
            Qfront = Qfront->next;

        free(temp);
        return v;
    }
}

int isConnected(char **graph,int noOfVertices)
{
    int i;

    //let random source vertex be vertex 0;
    BFS(graph,0,noOfVertices);

    for(i = 0;i < noOfVertices;++i)
        if(visited[i] == 'N')
         return 0;//0 implies false;

    return 1;//1 implies true;
}

void BFS(char **graph,int v,int noOfVertices)
{        
    int i,vertex;
    visited[v] = 'Y';
    enqueue(v);    
    while((vertex = deque()) != -1)
    {            
        for(i = 0;i < noOfVertices;++i)
            if(graph[vertex][i] == 1 && visited[i] == 'N')
            {
                enqueue(i);
                visited[i] = 'Y';
            }
    }
}
 
 For Finding all the Connected components of an undirected graph, we only need to add 2 lines of code to the BFS function. The idea is to call BFS function until all vertices are visited. 
 The lines to be added are: 
 printf("\nConnected component %d\n",++count);    
//count is a global variable initialized to 0
//add this as first line to BFS function    
 
 AND 
 printf("%d ",vertex+1);
add this as first line of while loop in BFS
 
 and we define the following function: 
 void listConnectedComponents(char **graph,int noOfVertices)
{
    int i;
    for(i = 0;i < noOfVertices;++i)
    {
        if(visited[i] == 'N')
            BFS(graph,i,noOfVertices);

    }
}
 
 
 
 
 
 
 
 
 created  Feb 25 at 13:33 
 
 
 
 
 
 
 
 
   
 
 
   edit 
 share 
 discuss 
 request improvement 
   edit 
 move example 
 delete example 
 
 
 
 
 
 
 + 
            Add Example
         
 
 
 
        Please consider making a request to improve this example.
         Request Improvement 
 
 
 
 
 
 Syntax 
 
 
 Syntax 
 
 
 
   add syntax 
 
 
 
 
 
 
 
 Parameters 
 
 
 Parameters 
 
 
 
   add parameters 
 
 
 
 
 
 
 
 Remarks 
 
 
 Remarks 
 
 
 
   add remarks 
 
 
 
 
 
 
 
 edited  Feb 25 at 13:33 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 Still have a question about Breadth-First Search? 
 Ask Question 
 
 
 
 
 Topic Outline 
 
 3 Examples 
 
 
 
 
 Finding the Shortest Path from Source to other Nodes 
 
 
 Finding Shortest Path from Source in a  2D graph 
 
 
 Connected Components Of Undirected Graph Using BFS. 
 
 Show more 
 
 
 
 
                    Blog
                 
 
 
 
 
   
 
 
 Trends in Government Software Developers 
 
 
 
 
 
 
   
 
 
 Introducing Channels: Private Q&A for Your Team 
 
 
 
 
   
 
                var ados = ados || {}; ados.run = ados.run || [];
                ados.run.push(function () { ados_add_placement(22,499571,"adzerk619534794",5).setZone(56016); });
             
 
 
 
 
        StackExchange.ready(function () { $.get('/documentation/algorithm/ivc/7215-636356029096593695:dwo6n11ucoqzojkh4xg164rojps.gif?topicId=7215'); });
     
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                    Topic Outline
                         
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 Save Draft 
 Discard 
 
 
 
 
 Sign up or log in 
 Save edit as a guest 
 Join Stack Overflow 
 
 
 
 Using Google 
 
 
 Using Facebook 
 
 
 Using Email and Password 
 
 
 
 
 Name 
 
 
 
 Email 
 
 Save Draft 
 
 
 
 
 We recognize you from another Stack Exchange Network site! 
 Join and Save Draft 
 
 Discard Draft 
 
 
 
 
 
 
 
 
 
 
 
 
 
 Stack Overflow 
 
 Questions 
 Jobs 
 Developer Jobs Directory 
 Documentation 
 Help 
 Mobile 
 
 
 
 Stack Overflow  Business 
 
 Talent 
 Ads 
 Enterprise 
 Insights 
 
 
 
 Company 
 
 About 
 Press 
 Work Here 
 Legal 
 Privacy Policy 
 Contact Us 
 
 
 
 
 
 Stack Exchange  Network 
 
 Technology 
 Life / Arts 
 Culture / Recreation 
 Science 
 Other 
 
 
 
 
 
 Stack Overflow 
 Server Fault 
 Super User 
 Web Applications 
 Ask Ubuntu 
 Webmasters 
 Game Development 
 
 TeX - LaTeX 
 Software Engineering 
 Unix & Linux 
 Ask Different (Apple) 
 WordPress Development 
 Geographic Information Systems 
 Electrical Engineering 
 
 Android Enthusiasts 
 Information Security 
 Database Administrators 
 Drupal Answers 
 SharePoint 
 User Experience 
 Data Science 
 
 Mathematica 
 Salesforce 
 ExpressionEngine® Answers 
 Blender 
 Network Engineering 
 Cryptography 
 Code Review 
 
 Magento 
 Software Recommendations 
 Signal Processing 
 Emacs 
 Raspberry Pi 
 Programming Puzzles & Code Golf 
 Ethereum 
 
 
 
                            more (27)
                         
 
 
 
 
 
 
 Photography 
 Science Fiction & Fantasy 
 Graphic Design 
 Movies & TV 
 Music: Practice & Theory 
 Worldbuilding 
 Seasoned Advice (cooking) 
 
 Home Improvement 
 Personal Finance & Money 
 Academia 
 Law 
 
 
 
                            more (16)
                         
 
 
 
 
 
 
 English Language & Usage 
 Skeptics 
 Mi Yodeya (Judaism) 
 Travel 
 Christianity 
 English Language Learners 
 Japanese Language 
 
 Arqade (gaming) 
 Bicycles 
 Role-playing Games 
 Anime & Manga 
 Puzzling 
 Motor Vehicle Maintenance & Repair 
 
 
 
                            more (32)
                         
 
 
 
 
 
 
 MathOverflow 
 Mathematics 
 Cross Validated (stats) 
 Theoretical Computer Science 
 Physics 
 Chemistry 
 Biology 
 
 Computer Science 
 Philosophy 
 
 
 
                            more (10)
                         
 
 
 
 
 
 
 Meta Stack Exchange 
 Stack Apps 
 API 
 Data 
 Area 51 
 
 
 
 
 
 Blog 
 Facebook 
 Twitter 
 LinkedIn 
 
 
 
                                    site design / logo © 2017 Stack Exchange Inc; user contributions licensed under  cc by-sa 3.0 
                                    with  attribution required .
                                     rev 2017.7.13.1278 
 
 
 
 
 
 
 
 
 Stack Overflow works best with JavaScript enabled
             
 
 
 var z=document.createElement("script");z.type="text/javascript",z.async=!0,z.src="https://static.adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s); 
 
var ados = ados || {};
ados.run = ados.run || [];

 
 
            (function(i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m);
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
                ga('create', 'UA-5620270-1');
                ga('create', 'UA-5620270-60', {name: 'pageData', sampleRate: 100 });
                ga('send', 'pageview');
                ga('pageData.send', 'pageview');
        var _qevents = _qevents || [],
            _comscore = _comscore || [];
        (function () {
            var ssl='https:'==document.location.protocol,
                s=document.getElementsByTagName('script')[0],
                qc=document.createElement('script');
                qc.async = true;
                qc.src = (ssl ? 'https://secure' : 'http://edge') + '.quantserve.com/quant.js';
                s.parentNode.insertBefore(qc, s);
                _qevents.push({ qacct: "p-c1rF4kxgLUzNc" });
                            var sc=document.createElement('script');
                sc.async=true;
                sc.src=(ssl?'https://sb':'http://b') + '.scorecardresearch.com/beacon.js';
                s.parentNode.insertBefore(sc, s);
                _comscore.push({ c1: "2", c2: "17440561" });
        })();

     
 
                
                (function(appendChild) {
                    Node.prototype.appendChild = function() {
                        var parent = this;
                        var newNode = arguments[0];
                        if (parent.nodeName === 'HEAD'
                            && newNode
                            && newNode.nodeName === 'SCRIPT'
                            && newNode.src) {
                            
                            window.setTimeout(function() {
                                var result = newNode.src.match(/^https:\/\/maps\.googleapis\.com\/maps\/api\/place\/js\/(\w+)Service\./i) || [];
                                var service = result[1];
                                if (service) {
                                    if (service === 'Autocompletion') service =  2;
                                    else if (service === 'Place') service = 1;
                                    else service = 0;
                                    StackExchange.using('gps', function() {
                                        StackExchange.gps.track('google_maps_places_api.call', { service: service });
                                    });
                                }
                            }, 0);
                        }
                        return appendChild.apply(this, arguments);
                    };
                })(Node.prototype.appendChild);
             
